## did:indy Operations

There is a description of types and operations that are available in case of using [`indy-node`](https://github.com/hyperledger-indy/indy-node) with [`indy-plenum`](https://github.com/hyperledger-indy/indy-plenum) repositories.

### Creation

Creation of a `did:indy` DID is performed by an authorized entity executing a `NYM` ledger transaction on a given Indy network. An Indy [[ref: NYM]] transaction includes an identifier (`dest`), an ED25519 verification key (`verkey`), an optional JSON item (`diddocContent`), and an optional NYM transaction `version`. The [[ref: NYM]] is written to a specific Indy network with a given `namespace`. The following validation MUST be performed prior to executing the transaction to create the DID:

- Based on the configured authorization rules of the specific Indy ledger, the transaction may have to be signed by others, such as a Trustee or Endorser. If transaction is not authorized, the transaction MUST be rejected and an error returned to the client.

- The Indy ledger MUST verify the relationship between the namespace identifier component of the DID and the initial public key (verkey) according to the NYM transaction `version` number described [below](#nym-transaction-version). If the relationship between the data elements fails verification, the transaction MUST be rejected and an error returned to the client.

- The [[ref: NYM]] transaction requires that the transaction to be written is signed by the DID controller. The ledger MUST verify the signature using the [[ref: NYM]] `verkey`. If the signature can not be validated, the transaction MUST be rejected and an error returned to the client.

- The Indy ledger MUST check that the data in the [[ref: NYM]] produces valid JSON and MUST do a limited DIDDoc validation check prior to writing the [[ref: NYM]] object to the ledger. Details of the assembly and verification are [below](#diddoc-assembly-and-verification). If the DIDDoc validation fails, the transaction MUST be rejected and an error returned to the client.

Although the DIDDoc is returned from the DIDDoc assembly and verification process, the DIDDoc is not used further by the ledger.

Once the validation checks are completed, the [[ref: NYM]] transaction is written to the Indy distributed ledger. If the [[ref: NYM]] write operation fails, an error is returned to the client.

On successfully writing the transaction to the Indy distributed ledger a success status is returned to the client.

#### NYM Transaction Version

The NYM transaction `version` specifies the required level of validation of the relationship between the namespace identifier component of the DID and the initial public key (verkey). This field is optional, but if the NYM transaction `version` is provided, it must be set upon creation and cannot be updated. The accepted values are as follows:

- 0 or NYM transaction `version` is not set: No validation of namespace identifier and initial verkey binding is performed.
- 1: Validation is performed according to the `did:sov` method, in which the DID must be the first 16 bytes of the Verification Method public key.
- 2: Validation is performed according to the `did:indy`, in which the namespace identifier component of the DID (last element) is derived from the initial public key of the DID, using the base58 encoding of the first 16 bytes of the SHA256 of the Verification Method public key (`did = Base58(Truncate_msb(16(SHA256(publicKey))))`). This DID is considered self-certifying.

The NYM transaction `version` is distinct from the DID version described [below](#did-versions), which allows for resolution of DIDs at the specified `versionId` or `versionTime`.

#### Backwards Compatibility

Prior to `did:indy`, the unenforced convention in the [Indy SDK](https://github.com/hyperledger-indy/indy-sdk) was to use the following to demonstrate the relationship between the DID and its initial verkey: `For an Ed25519 key: Convert into Base58char the first 16 bytes of the 256 bit public key (verkey).` If the `did:indy` approach to verifying the relationship between the DID and its initial verkey fail, a client resolving a DID MAY attempt to verify the relationship using the old Indy SDK convention.

When using the old Indy SDK convention of using the first 16 bytes of the verkey, related convention allowed for the placement of a shortened verkey (prefixed with `~`) in the NYM `verkey` field, such that the full verkey was dynamically generated by combining the DID and shortened verkey. That convention is **NOT** used in "did:indy", but client resolvers using DIDs created prior to `did:indy` MUST detect and convert shortened verkeys to full verkeys as necessary.

#### DIDDoc Assembly and Verification

The DIDDoc returned when a `did:indy` DID is resolved is not directly stored in an Indy ledger document. Instead, the DIDDoc must be assembled from data elements in the Indy `NYM` object based on a series of steps. When a [[ref: NYM]] is created or updated the ledger MUST assemble the DIDDoc (following the steps) and validate the DIDDoc. As well, an Indy DID resolver will receive the [[ref: NYM]] from the ledger and the non-validation steps must be followed to assemble the DIDDoc for the resolved DID.

The `diddocContent` item is stored directly in the ledger state and has a maximum size of 10 KiB (10 x 1024 bytes). If the `diddocContent` item contains a `@context` item, the resulting DIDDoc is considered JSON-LD. It is the responsibility of the content creator to ensure that it is valid JSON-LD.

##### DIDDoc Validation

The following validation must be performed on a DIDDoc:

- Content must not include `id` at root of the object
- Content must not include any nested objects with an `id` ending in \<nym\>#verkey

This minimal validation allows for the evolution of the DIDDoc without the effort of updating deployments with each minor update. Instead, the writers and resolvers must ensure that the DIDDoc is valid beyond these basic requirements.

#### DIDDoc Assembly Steps

The following are the steps for assembling a DIDDoc from its inputs.

1. If the `verkey` is `null` the DID has been deactivated, and no DIDDoc is created. Assembly is complete; return a success status.
2. The Indy network instance `namespace`, the [[ref: NYM]] `dest` and the [[ref: NYM]] `verkey` items are merged into a text template to produce a base DIDDoc.
    1. See the template in the [Base DIDDoc Template](#base-diddoc-template) section of this document.
    2. If there is no `diddocContent` item in the [[ref: NYM]], assembly is complete; return the DIDDoc and a success status.
3. If the `diddocContent` item is included in the [[ref: NYM]], it is verified and merged into the DIDDoc.
    1. The `diddocContent` item MUST NOT have an `id` item. If found, exit the assembly process, returning an error.
    2. The `diddocContent` MUST NOT contain an item with the same `id` values as those from the [[ref: NYM]]-generated DIDDoc. If a matching `id` is found, exit and return an error.
    3. If the `diddocContent` item contains `verificationMethod` and/or `authentication` items, these MUST be arrays. Merge the entries into the respective arrays of the DIDDoc.
    4. Add the other items of the `diddocContent` to the DIDDoc.
4. The resulting DIDDoc text must be valid JSON. If not JSON, exit and return an error.
5. The resulting JSON must be a valid DIDDoc. Perform the [DIDDoc Validation](#diddoc-validation) process. If not a DIDDoc, exit and return an error.
6. Return the DIDDoc and a success status.

The remainder of this section goes through examples of base DIDDoc template (step 2, above) that is created prior to processing the optional `diddocContent` item, and an example of processing a `diddocContent` item.

##### Base DIDDoc Template

The base DIDDoc template is static text that forms a JSON structure. To transform a [[ref: NYM]] to its minimal DIDDoc, the Indy network instance's `namespace`, and the [[ref: NYM]] values `dest` and `verkey` are inserted into the template as indicated below.

```json
{
  "id": "did:indy:<namespace>:<dest>",
  "verificationMethod": [{
      "id": "did:indy:<namespace>:<dest>#verkey",
      "type": "Ed25519VerificationKey2018",
      "publicKeyBase58": "<verkey>",
      "controller": "did:indy:<namespace>:<dest>"
    }
  ],
  "authentication": [
    "did:indy:<namespace>:<dest>#verkey"
  ]
}
```

Assuming values `sovrin` for the `namespace`, `123456` for `dest` and `789abc` for the `verkey` the resulting JSON DIDDoc would be:

::: example Base DIDDoc sovrin example
```json
{
  "id": "did:indy:sovrin:123456",
  "verificationMethod": [{
      "id": "did:indy:sovrin:123456#verkey",
      "type": "Ed25519VerificationKey2018",
      "publicKeyBase58": "789abc",
      "controller": "did:indy:sovrin:123456"
    }
  ],
  "authentication": [
    "did:indy:sovrin:123456#verkey"
  ]
}
```
:::

##### Example Extended DIDDoc Item

An example of a [[ref: NYM]]'s extended DIDDoc handling is provided below. In the example below, the `diddocContent` item adds a DIDcomm service endpoint to the resolved DIDDoc. Note that in the example, an `@context` item is included in the `diddocContent`, which causes the result DIDDoc to be a JSON-LD document, rather than plain JSON.

::: example Extended DIDDoc Item example
```json
"diddocContent" : {
  "@context" : [
      "https://www.w3.org/ns/did/v1",
      "https://identity.foundation/didcomm-messaging/service-endpoint/v1"
  ],
  "service": [
    {
      "id": "did:indy:sovrin:123456#did-communication",
      "type": "did-communication",
      "priority": 0,
      "serviceEndpoint": "https://example.com",
      "recipientKeys": [ "#verkey" ],
      "routingKeys": [ ]
    }
  ]
}
```
:::

Applying the DIDDoc assembly rules to the example above, the following assembled DIDDoc is produced (it is the responsibility of the content creator to ensure that the DIDDoc is valid JSON-LD):

::: example assembled Extended JSON-LD DIDDoc Item  example
```json
{
  "@context": [
    "https://www.w3.org/ns/did/v1",
    "https://identity.foundation/didcomm-messaging/service-endpoint/v1"
  ],
  "id": "did:indy:sovrin:123456",
  "verificationMethod": [{
      "id": "did:indy:sovrin:123456#verkey",
      "type": "Ed25519VerificationKey2018",
      "publicKeyBase58": "789abc",
      "controller": "did:indy:sovrin:123456"
    }
  ],
  "authentication": [
    "did:indy:sovrin:123456#verkey"
  ],
  "service": [
    {
      "id": "did:indy:sovrin:123456#did-communication",
      "type": "did-communication",
      "priority": 0,
      "serviceEndpoint": "https://example.com",
      "recipientKeys": [ "#verkey" ],
      "routingKeys": [ ]
    }
  ]
}
```
:::

#### Key Agreement

By default there is no key agreement section in an assembled DIDDoc. If the DID Controller wants a key agreement key in the DIDDoc, they must explicitly add it by including it in the `diddocContent`. For an ED25519 verification key, an X25519 key agreement key could be derived from the verkey (by the client), or a new key agreement key can be generated and used.

#### The "endpoint" ATTRIB

Prior to the definition of this DID Method, a convention on Indy ledgers to associate an endpoint to a [[ref: NYM]] involved adding an [[ref: ATTRIB]] ledger object with a `raw` value of contain the JSON for a name-value pair of `endpoint` and a URL endpoint, often an IP address.

We strongly encourage anyone using the "ATTRIB `endpoint`" convention to update their [[ref: NYM]] on the ledger to use the `diddocContent` item as soon as possible, as the [[ref: ATTRIB]] is deprecated with the introduction of the `did:indy` DID Method.

If a client retrieves a [[ref: NYM]] that has a `diddocContent` data element, the client should assume that the DID Controller has made the [[ref: ATTRIB]] (if any) obsolete and the client SHOULD NOT retrieve the [[ref: ATTRIB]] associated with the DID.

If clients want to continue to retrieve and use the `endpoint` [[ref: ATTRIB]] transaction associated with a [[ref: NYM]], we recommend that the endpoint value (along with `namespace` and `dest`) be used as if the following was the `diddocContent` item in the [[ref: NYM]].

``` json
"diddocContent" : {
  "@context" : [ "https://identity.foundation/didcomm-messaging/service-endpoint/v1" ],
  "service": [
    {
      "id": "did:indy:sovrin:123456#did-communication",
      "type": "did-communication",
      "priority": 0,
      "serviceEndpoint": "https://example.com",
      "recipientKeys": [ "#verkey" ],
      "routingKeys": [ ]
    }
  ]
}
```

The DIDDoc produced by the [[ref: NYM]] and "endpoint" [[ref: ATTRIB]] would be created using the DIDDoc Assembly Rules and using the `diddocContent` from the [[ref: ATTRIB]] instead of the [[ref: NYM]] item.

#### The "diddocContent" ATTRIB

As described in previous sections, this DID Method introduces the optional `diddocContent` item in [[ref: NYM]] transactions, which is used in the [DIDDoc assembly process](#diddoc-assembly-and-verification).

There may however be networks which use a version of Hyperledger Indy that doesn't support this field yet. In this case, when [creating](#creation) or [updating](#update) a `did:indy` DID, implementations MAY write the `diddocContent` to an [[ref: ATTRIB]] transaction with a `raw` value containing the JSON for a name-value pair with name `diddocContent`, instead of using the field in a [[ref: NYM]] transaction.

Once such a network is upgraded to a version that supports the `diddocContent` item in the [[ref: NYM]], we strongly encourage anyone using the "ATTRIB `diddocContent`" convention to update their [[ref: NYM]] on the ledger to use the `diddocContent` item as soon as possible, analogous to the ["ATTRIB `endpoint`" convention](#the-endpoint-attrib).

If a client retrieves a [[ref: NYM]] that has a `diddocContent` data element, the client should assume that the DID Controller has made the [[ref: ATTRIB]] (if any) obsolete and the client SHOULD NOT retrieve the [[ref: ATTRIB]] associated with the DID.

Otherwise, the client SHOULD attempt to retrieve the `diddocContent` [[ref: ATTRIB]] transaction associated with a [[ref: NYM]] and, if present, treat it as if its `raw` value was the value of the `diddocContent` item in the [[ref: NYM]].

The following is an example ATTRIB transaction with a `raw` value containing `diddocContent`:

::: example Example ATTRIB transaction with a `raw` value containing `diddocContent`
```json
{
	"txn": {
		"data": {
			"dest": "P8xKoMHo5tvaCBu9sg7qmE",
			"raw": "{\"diddocContent\":{\"@context\":[\"https://www.w3.org/ns/did/v1\",\"https://identity.foundation/didcomm-messaging/service-endpoint/v1\"],\"service\":[{\"id\":\"did:indy:sovrin:123456#did-communication\",\"type\":\"did-communication\",\"priority\":0,\"serviceEndpoint\":\"https://example.com\",\"recipientKeys\":[\"#verkey\"],\"routingKeys\":[]}]}}"
		},
		"metadata": {
			"reqId": 1681588180411147000,
			"from": "P8xKoMHo5tvaCBu9sg7qmE",
			"digest": "38f422258c5f674f60e08274cf400a351dabfb3f5c80b59966f2889947bf3387",
			"payloadDigest": "0aa1a7d1de92da1056c7702dee10fba0cc7d13378f6cd11ec392da2d95c3e2fb"
		},
		"protocolVersion": 2,
		"type": "100"
	},
	"txnMetadata": {
		"seqNo": 807,
		"txnId": "P8xKoMHo5tvaCBu9sg7qmE:1:9bc57c8357576385437819bd163d4cd6dda6acb9a424033d50a646bc54438ef3",
		"txnTime": 1681588183
	}
}
```
:::

### Update

Updating a DID using the Indy DID Method occurs when a `NYM` transaction is performed by the [[ref: NYM]]'s controller (the "owner" of the [[ref: NYM]]) using the same identifier (`dest`). The Indy ledger MUST validate the [[ref: NYM]] transaction prior to writing the [[ref: NYM]] to the ledger.

When a [[ref: NYM]] is updated, the identifier (`dest`) for the [[ref: NYM]] does not change, but other values, including the `verkey` and `diddocContent`, may be changed. This means that (as expected) the DID itself does not change, but the DIDDoc returned by the DID may change. The NYM transaction `version` must not be updated.

The following validation steps are performed prior to the update being written to the ledger:

- Based on the configured authorization rules of the specific Indy ledger, the transaction may have to be signed by others, such as a Trustee or Endorser. If transaction is not authorized, the transaction MUST be rejected and an error returned to the client.

- The [[ref: NYM]] transaction requires that the transaction to be written is signed by the DID controller using the existing `verkey`. The ledger MUST verify the DID controller's signature. If the DID controller's signature cannot be validated, the transaction MUST be rejected and an error returned to the client.

- The Indy ledger MUST check that the data in the [[ref: NYM]] produces valid JSON and MUST do a limited DIDDoc validation check prior to writing the [[ref: NYM]] object to the ledger. Details of the assembly and verification are [here](#diddoc-assembly-and-verification). If the DIDDoc validation fails, the transaction MUST be rejected and an error returned to the client.

- The Indy ledger checks that the NYM transaction `version` is not updated. If the `version` is updated, the transaction MUST be rejected and an error returned to the client.

Although the DIDDoc is returned from the DIDDoc assembly and verification process, the DIDDoc is not used further by the ledger.

Once the validation checks are completed, the [[ref: NYM]] update transaction is written to the Indy distributed ledger. If the [[ref: NYM]] write operation fails, an error MUST be returned to the client.

On successfully writing the update transaction to the Indy distributed ledger a success status is returned to the client.

### Read

Reading (resolving) a `did:indy` DID requires finding and connecting to the Indy ledger instance holding the DID, retrieving the [[ref: NYM]] associated with the DID, verifying the state proof for the returned [[ref: NYM]], and then assembling the DIDDoc. A client/resolver must perform the following steps to complete the process.

1. Given a `did:indy` DID, extract the `<namespace>` component of the DID.
2. If the namespace (specific Indy instance) is known to the resolver and the resolver is connected to the ledger continue. If not:
    1. To read the DIDDoc, the client must get the genesis file for the Indy instance and connect to the ledger. For example, the guidance in the [finding Indy ledgers](#finding-indy-ledgers) can be used to discover previously unknown Indy ledgers.
    2. If the client cannot find the Indy network terminate the process and return a "Not Found" status to the caller.
    3. If the client chooses not to connect to the Indy network terminate the process and return a "Not Authorized" status to the caller.
3. Once connected, the `GET_NYM` Indy request is used, passing in the `<namespace identifier>` component.
    1. If resolving a prior version of the DID, a different call is used in at this point. See the [DID Versions](#did-versions) section of this document (below) for more details.
4. If the call fails, terminate the process and return a "Not Found" status to the caller.
5. If a [[ref: NYM]] is returned, use the state proof to verify the result. If the verification fails, terminate the process and return a "Not Found" status to the caller.
6. Use the DID `<namespace>` component, the [[ref: NYM]] data items `dest`, `verkey`, and (optional) `diddocContent` to assemble the DIDDoc using the [DIDDoc assembly process](#diddoc-assembly-and-verification) defined earlier in this document.
    1. Since the assembly validation was done by the ledger before writing the document, the process should be successful.
7. If the DIDDoc is empty (because the `verkey` is null) return a "Not Found" result, otherwise, return the DIDDoc.

#### DID Versions

In resolving a `did:indy` DID, the DID resolution query parameters `versionId` and `versionTime` may be used. When used, process to retrieve the [[ref: NYM]] from the ledger (step 3 above) is different.

If the parameter `versionId` is used, the value must be an Indy ledger `seqno` for the requested [[ref: NYM]] on the queried Indy ledger. Instead of using the `GET_NYM` call, the Indy `GET_TXN` call is used, passing in the `seqno`. The result is checked that it is the [[ref: NYM]] matching the DID namespace identifier. If so the call is considered to have failed. Either way, the process continues at Step 4.

If the parameter `versionTime` is used, the `GET_NYM` transaction is called with the appropriate `versionTime` timestamp as an additional parameter. The `versionTime` parameter MUST be a XML datetime, as defined in the [DID Core specification](https://www.w3.org/TR/did-core/#did-parameters), and will be converted into a POSIX timestamp by the resolver. The Indy ledger code tries to find the instance of the requested [[ref: NYM]] that was active at that time (using ledger transaction timestamps) and returns it (if found) or the call fails. Either way, the process continues at Step 4.

### Deactivate

Deactivation of a `did:indy` DID is done by setting the [[ref: NYM]] verkey to null. Once done, the DIDDoc is not found (per
the [DIDDoc Assembly Steps](#diddoc-assembly-steps)) and the [[ref: NYM]] cannot be updated again.
